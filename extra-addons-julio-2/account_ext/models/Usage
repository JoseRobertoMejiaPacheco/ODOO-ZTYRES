/usr/bin/odoo shell -d CONTABILIDAD --config /etc/odoo/odoo.conf --xmlrpc-port=8005  --workers=30

#Crear movimientos de valoración de inventario
import pandas as pd
from datetime import datetime

import pytz

def convertir_y_extraer_fecha(fecha_utc):
    # Obtener la fecha y hora en formato datetime
    fecha_hora_utc = fecha_utc
    # Convertir fecha_utc a objeto datetime si no lo es
    if not isinstance(fecha_hora_utc, datetime):
        fecha_hora_utc = datetime.combine(fecha_hora_utc, datetime.min.time())
    # Definir la zona horaria a la que deseas convertir (por ejemplo, 'America/Mexico_City')
    zona_horaria_destino = 'America/Mexico_City'
    # Crear objetos de zona horaria para UTC y la zona horaria de destino
    tz_utc = pytz.timezone('UTC')
    tz_destino = pytz.timezone(zona_horaria_destino)
    # Convertir la fecha y hora de UTC a la zona horaria de destino
    fecha_hora_destino = tz_utc.localize(fecha_hora_utc).astimezone(tz_destino)
    # Extraer la parte de la fecha (tipo date)
    fecha_destino = fecha_hora_destino.date()
    # Ahora 'fecha_destino' contiene la fecha en la zona horaria de destino
    return fecha_destino

sp = self.env['stock.picking']
domain = [('sale_id', '!=', False), ('date_done', '>=', '2024-01-01')]
sp_ids = sp.search(domain)
svl = self.env['stock.valuation.layer']

data = []

for sp in sp_ids:
    svls = svl.search([('stock_move_id', 'in', sp.move_ids.ids)])
    for svl in svls:
        vals = {}
        if not svl.account_move_id:
            svl._validate_accounting_entries()
            if svl.account_move_id:
                svl.account_move_id.with_context(is_redo_move=True).write({'date':convertir_y_extraer_fecha(svl.create_date)})
                for line in svl.account_move_id.line_ids:
                    vals = {
                        'picking_id': sp.id,
                        'picking_name': sp.name,
                        'svl_id': svl.id,
                        'svl_date': svl.create_date,
                        'svl_move_id': svl.account_move_id.name,
                        'svl_move_date': svl.account_move_id.date,
                        'svl_move_name': svl.account_move_id.name,
                        'account_code': line.account_id.code,
                        'account_name': line.account_id.name,
                        'debit': line.debit,
                        'credit': line.credit,
                    }
                    data.append(vals)

# Create a DataFrame
df = pd.DataFrame(data)

# Save to Excel
df.to_excel('/mnt/extra-addons/Asientos de Valoracion de inventario creados.xlsx')

    
    



459973
459623


import pandas as pd
am = self.env['account.move']
apr = self.env['account.partial.reconcile']
domain = [('amount_residual', '>', 0),('state', 'in', ['posted']), ('date', '>=', '2021-01-01'),('date', '<=', '2021-12-31'),('move_type', 'in', ['out_invoice'])]
am_ids = am.search(domain) + am.search([('amount_residual','>',0)])
total = len(am_ids)
count = 0
data = []

for move in am_ids:
    vals = {}
    lines = move.line_ids.filtered(lambda line: line.display_type not in ['product', 'tax', 'payment_term'])
    lines.full_reconcile_id.unlink()
    apr.search([('debit_move_id', 'in', lines.ids)]).unlink()
    apr.search([('credit_move_id', 'in', lines.ids)]).unlink()
    lines.with_context(force_delete=True).unlink()
    line_products = move.line_ids.filtered(lambda line: line.account_id.account_type == 'income')
    for line in line_products:
        if line.product_id.categ_id.property_stock_valuation_account_id:
            line.with_context(is_redo_move=True).write({'account_id': line.product_id.categ_id.property_stock_valuation_account_id.id})
        else:
            vals.update({'Log':'Sin cuenta de Valoración de Inventario Revisar'})
            vals.update({
                'move_id': move.id,
                'move_name': move.name,
                'move_date': move.date,
                'line_date': line.date,
                'account_code': line.account_id.code,
                'account_name': line.account_id.name,
                'debit': line.debit,
                'credit': line.credit,
            })
    print(move.id)
    move.with_context(is_redo_move=True)._post()
    new_lines = move.line_ids.filtered(lambda line: line.display_type not in ['product', 'tax', 'payment_term'])
    for line in new_lines:
        vals.update({
            'move_id': move.id,
            'move_name': move.name,
            'move_date': move.date,
            'line_date': line.date,
            'account_code': line.account_id.code,
            'account_name': line.account_id.name,
            'debit': line.debit,
            'credit': line.credit,
        })
    print(new_lines.full_reconcile_id)
    data.append(vals)
    count = count + 1
    print('%s de %s' % (count, total))

df = pd.DataFrame(data)

# Guardar en Excel
df.to_excel('/mnt/extra-addons/Asientos de Facturas Erroneas LG.xlsx')


